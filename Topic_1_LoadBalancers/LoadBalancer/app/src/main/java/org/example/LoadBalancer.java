/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import com.sun.net.httpserver.*;
import java.io.*;
import java.net.*;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class LoadBalancer {
    // ---- Backend model ----
    static final class Backend {
        final URI baseUri;
        volatile boolean alive = true;
        final AtomicInteger inFlight = new AtomicInteger(0);

        Backend(URI baseUri) {
            this.baseUri = baseUri;
        }

        URI map(URI incoming) {
            // Preserve path+query; replace scheme/host/port with backend's
            try {
                return new URI(
                        baseUri.getScheme(),
                        baseUri.getUserInfo(),
                        baseUri.getHost(),
                        baseUri.getPort(),
                        incoming.getPath(),
                        incoming.getQuery(),
                        incoming.getFragment()
                );
            } catch (URISyntaxException e) {
                throw new RuntimeException(e);
            }
        }
        @Override public String toString() {
            return baseUri + " (alive=" + alive + ", inFlight=" + inFlight.get() + ")";
        }
    }

    // ---- Strategy: Round Robin that skips down backends ----
    static final class RoundRobinPicker {
        private final List<Backend> backends;
        private final AtomicInteger idx = new AtomicInteger(0);
        RoundRobinPicker(List<Backend> b) { this.backends = b; }
        Backend nextAlive() {
            int n = backends.size();
            for (int t = 0; t < n; t++) {
                int i = Math.floorMod(idx.getAndIncrement(), n);
                Backend b = backends.get(i);
                if (b.alive) return b;
            }
            return null; // none alive
        }
    }

    // ---- Health checker ----
    static final class HealthChecker implements Runnable {
        private final List<Backend> backends;
        private final HttpClient hc = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(2)).build();

        HealthChecker(List<Backend> b) { this.backends = b; }
        @Override public void run() {
            for (Backend b : backends) {
                try {
                    URI u = b.baseUri.resolve("/health");
                    HttpRequest req = HttpRequest.newBuilder(u)
                            .timeout(Duration.ofSeconds(2))
                            .GET().build();
                    HttpResponse<Void> resp = hc.send(req, HttpResponse.BodyHandlers.discarding());
                    boolean ok = resp.statusCode() >= 200 && resp.statusCode() < 300;
                    b.alive = ok;
                } catch (Exception e) {
                    b.alive = false;
                }
            }
        }
    }

    // ---- Proxy handler ----
    static final class ProxyHandler implements HttpHandler {
        private final RoundRobinPicker picker;
        private final HttpClient client;

        ProxyHandler(RoundRobinPicker picker) {
            this.picker = picker;
            this.client = HttpClient.newBuilder()
                    .version(HttpClient.Version.HTTP_1_1)
                    .connectTimeout(Duration.ofSeconds(5))
                    .build();
        }

//        @Override public void handle(HttpExchange ex) throws IOException {
//            Backend backend = picker.nextAlive();
//            if (backend == null) {
//                sendPlain(ex, 503, "No backend available\n");
//                return;
//            }
//
//            // Build target URI
//            URI target = backend.map(ex.getRequestURI());
//
//            // Copy request method, headers, body
//            String method = ex.getRequestMethod();
//            byte[] reqBody = readAll(ex.getRequestBody());
//            HttpRequest.Builder rb = HttpRequest.newBuilder(target)
//                    .timeout(Duration.ofSeconds(10));
//
//            // Set method + body
//            if (method.equalsIgnoreCase("GET") || method.equalsIgnoreCase("DELETE")) {
//                rb.method(method, HttpRequest.BodyPublishers.noBody());
//            } else {
//                rb.method(method, HttpRequest.BodyPublishers.ofByteArray(reqBody));
//            }
//
//            // Forward headers (skip hop-by-hop)
//            Headers h = ex.getRequestHeaders();
//            for (String k : h.keySet()) {
//                if (isHopByHop(k)) continue;
//                for (String v : h.get(k)) rb.header(k, v);
//            }
//            // Set Host to backend host
//            rb.header("Host", backend.baseUri.getHost() +
//                    (backend.baseUri.getPort() > 0 ? (":" + backend.baseUri.getPort()) : ""));
//
//            // Send
//            backend.inFlight.incrementAndGet();
//            HttpResponse<byte[]> resp;
//            try {
//                resp = client.send(rb.build(), HttpResponse.BodyHandlers.ofByteArray());
//            } catch (Exception e) {
//                backend.inFlight.decrementAndGet();
//                sendPlain(ex, 502, "Bad Gateway: " + e.getMessage() + "\n");
//                return;
//            }
//            backend.inFlight.decrementAndGet();
//
//            // Write back response
//            Headers outH = ex.getResponseHeaders();
//            resp.headers().map().forEach((k, vals) -> {
//                if (!isHopByHop(k)) outH.put(k, new ArrayList<>(vals));
//            });
//            ex.sendResponseHeaders(resp.statusCode(), resp.body().length);
//            ex.getResponseBody().write(resp.body());
//            ex.close();
//        }

        @Override public void handle(HttpExchange ex) throws IOException {
            try {
                Backend backend = picker.nextAlive();
                if (backend == null) { sendPlain(ex, 503, "No backend available\n"); return; }

                URI target = backend.map(ex.getRequestURI());
                String method = ex.getRequestMethod();
                byte[] reqBody = readAll(ex.getRequestBody()); // safe for GET

                HttpRequest.Builder rb = HttpRequest.newBuilder(target).timeout(Duration.ofSeconds(10));
                if (method.equalsIgnoreCase("GET") || method.equalsIgnoreCase("DELETE"))
                    rb.method(method, HttpRequest.BodyPublishers.noBody());
                else
                    rb.method(method, HttpRequest.BodyPublishers.ofByteArray(reqBody));

                // forward headers except hop-by-hop
                ex.getRequestHeaders().forEach((k, vals) -> {
                    if (!isHopByHop(k)) vals.forEach(v -> rb.header(k, v));
                });
                rb.header("Host", backend.baseUri.getHost() + (backend.baseUri.getPort() > 0 ? ":"+backend.baseUri.getPort() : ""));

                backend.inFlight.incrementAndGet();
                HttpResponse<byte[]> resp;
                try {
                    resp = client.send(rb.build(), HttpResponse.BodyHandlers.ofByteArray());
                } finally {
                    backend.inFlight.decrementAndGet();
                }

                // write back
                Headers out = ex.getResponseHeaders();
                resp.headers().map().forEach((k, vals) -> { if (!isHopByHop(k)) out.put(k, new ArrayList<>(vals)); });
                byte[] body = resp.body() == null ? new byte[0] : resp.body();
                ex.sendResponseHeaders(resp.statusCode(), body.length);
                ex.getResponseBody().write(body);
            } catch (Throwable t) {
                t.printStackTrace(); // see exact cause in console
                try { sendPlain(ex, 502, "Bad Gateway\n"); } catch (IOException ignore) {}
            } finally {
                try { ex.close(); } catch (Exception ignore) {}
            }
        }

        private static boolean isHopByHop(String k) {
            String s = k.toLowerCase(Locale.ROOT);
            return s.equals("connection") || s.equals("keep-alive") || s.equals("proxy-authenticate")
                    || s.equals("proxy-authorization") || s.equals("te") || s.equals("trailers")
                    || s.equals("transfer-encoding") || s.equals("upgrade");
        }

        private static byte[] readAll(InputStream is) throws IOException {
            try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
                byte[] buf = new byte[8192];
                int r;
                while ((r = is.read(buf)) != -1) bos.write(buf, 0, r);
                return bos.toByteArray();
            }
        }

        private static void sendPlain(HttpExchange ex, int code, String msg) throws IOException {
            byte[] b = msg.getBytes();
            ex.getResponseHeaders().set("Content-Type", "text/plain; charset=utf-8");
            ex.sendResponseHeaders(code, b.length);
            ex.getResponseBody().write(b);
            ex.close();
        }
    }

    // ---- Main: server, scheduler, simple logging ----
    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            System.err.println("Usage: java LoadBalancer <backendUrl1> <backendUrl2> ...");
            System.err.println("Example: java LoadBalancer http://localhost:9001 http://localhost:9002");
            return;
        }

        List<Backend> backends = new ArrayList<>();
        for (String a : args)
            backends.add(new Backend(URI.create(a)));

        // Initial health check once
        new HealthChecker(backends).run();

        // Start health checker every 5s
        ScheduledExecutorService ses = Executors.newSingleThreadScheduledExecutor();
        ses.scheduleAtFixedRate(new HealthChecker(backends), 5, 5, TimeUnit.SECONDS);

        // Start proxy server
        int port = 8080;
        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);
        //server.createContext("/", new ProxyHandler(new RoundRobinPicker(backends)));
        server.createContext("/", ex -> {
            try {
                byte[] body = "LB OK\n".getBytes();
                ex.getResponseHeaders().set("Content-Type", "text/plain; charset=utf-8");
                ex.sendResponseHeaders(200, body.length);
                ex.getResponseBody().write(body);
            } finally {
                ex.close();
            }
        });
        // Thread pool
        server.setExecutor(Executors.newFixedThreadPool(Math.max(4, Runtime.getRuntime().availableProcessors() * 2)));
        server.start();

        System.out.println("Load balancer listening on http://localhost:" + port);
        System.out.println("Backends: " + backends);
        System.out.println("Health check: GET /health on each backend");
    }
}